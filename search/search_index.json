{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"1. Overview This document contains an overview of Planning Visualiser. The Planning Visualiser is an open-source program which visualises solutions to Planning Problems. It is an executable Unity architecture in a browser. Click the Help link from inside the visualiser. Alternatively, view the html for the user manual at server/UserManual.html . For developer documentation, see * /Docs/Animation Profile Guide.md * Contains a guide to Animation Profiles and the Animation Profile Language * /VFG Guide.md * Contains a guide to the Visualisation File Generator Component * /Docs/Visualiser Guide.md * Contains a guide to the VisualiserComponent 1.1 Planning Problems For information about Planning Problems, see http://planning.domains/ Our application uses one 'Animation Profile' per problem domain. An Animation Profile is a user-written PDDL file which tells the Visualiser how a Domain is to be visualised. See section 3.2 for more information on Animation Profiles. 1.2 Scope Planning Visualiser currently has Animation Profiles for four problem domains; Blocks, Grid, Towers of Hanoi, and Logistics. Other simple problem domains may be added by writing an Animation Profile (see section 3.2). Planning visualiser can generate a solution using the solver on http://planning.domains/ . Alternatively, the user can provide their own solution from any solver, provided it conforms to the correct format. 2. Getting Started 2.1 In-browser (recommended) Visit http://planimation.planning.domains 2.2 Local server (For Development) 2.2.1 Install dependencies Unity - Install the Version 2018.2.1f1 from https://unity3d.com/. When installing, select \"Include WebGL\" Django REST - Follow the tutorial at http://www.django-rest-framework.org/tutorial/quickstart/ 2.2.2 Install project Clone the project from https://github.com/Planning-Visualisation/planning-visualisation 2.2.3 Run Run the server with the command 'python manage.py runserver' in the directory of the file manage.py (/swen90013-2018-pl/server) Open the project in Unity.The Unity application will communicate with the local server 2.3 Deployment (For Development) Follow the steps to setup the local server in 2.2 Build the project from the File menu in Unity Be sure to include all scenes in the build 3. Using the system Click the Help link from inside the visualiser. Alternatively, view the html for the user manual at server/UserManual.html . 4. Extending the system Planning Visualiser is modular and can be extended in multiple ways. Many simple domains can be captured in the existing Animation Profile language. For more complex domains, modifications may need to be made to the application. These are detailed in 4.3. and 4.4 4.2 Architecture overview Simple Overview Detailed Overview 4.3 Extending the Visualisation File Generator The Visualisation File Generator (VFG) decides where objects are on the screen and what they look like, based on the three files listed above. Most domain-related modifications to the system should be made to the VFG. For example, a new domain might require objects to be laid out in a manner which is not captured in the existing Animation Profile language. Extending the Visualisation File Generator requires only building the project in Django (see section 2.2). Modifications or extensions of the VFG need only be carried out only on the Django server (not Unity). For information on the VFG, see the file 'VFG Documentation'. 4.4 Extending the Visualiser Modifying the visualiser is only required when the current visualiser cannot adequately render the domain on-screen. It does not concern the logic of object layout. For example, a user might want to extend the Visualiser to support animated sprites. Extending the Visualiser requires building the project in Unity and Django (see section 2.2). Modifications or extensions of the Visualiser need only be carried out on Unity (not Django). For information on the Visualiser, see the file 'Visualiser Documentation'.","title":"Home"},{"location":"#1-overview","text":"This document contains an overview of Planning Visualiser. The Planning Visualiser is an open-source program which visualises solutions to Planning Problems. It is an executable Unity architecture in a browser. Click the Help link from inside the visualiser. Alternatively, view the html for the user manual at server/UserManual.html . For developer documentation, see * /Docs/Animation Profile Guide.md * Contains a guide to Animation Profiles and the Animation Profile Language * /VFG Guide.md * Contains a guide to the Visualisation File Generator Component * /Docs/Visualiser Guide.md * Contains a guide to the VisualiserComponent","title":"1. Overview"},{"location":"#11-planning-problems","text":"For information about Planning Problems, see http://planning.domains/ Our application uses one 'Animation Profile' per problem domain. An Animation Profile is a user-written PDDL file which tells the Visualiser how a Domain is to be visualised. See section 3.2 for more information on Animation Profiles.","title":"1.1 Planning Problems"},{"location":"#12-scope","text":"Planning Visualiser currently has Animation Profiles for four problem domains; Blocks, Grid, Towers of Hanoi, and Logistics. Other simple problem domains may be added by writing an Animation Profile (see section 3.2). Planning visualiser can generate a solution using the solver on http://planning.domains/ . Alternatively, the user can provide their own solution from any solver, provided it conforms to the correct format.","title":"1.2 Scope"},{"location":"#2-getting-started","text":"","title":"2. Getting Started"},{"location":"#21-in-browser-recommended","text":"Visit http://planimation.planning.domains","title":"2.1 In-browser (recommended)"},{"location":"#22-local-server-for-development","text":"","title":"2.2 Local server (For Development)"},{"location":"#221-install-dependencies","text":"Unity - Install the Version 2018.2.1f1 from https://unity3d.com/. When installing, select \"Include WebGL\" Django REST - Follow the tutorial at http://www.django-rest-framework.org/tutorial/quickstart/","title":"2.2.1 Install dependencies"},{"location":"#222-install-project","text":"Clone the project from https://github.com/Planning-Visualisation/planning-visualisation","title":"2.2.2 Install project"},{"location":"#223-run","text":"Run the server with the command 'python manage.py runserver' in the directory of the file manage.py (/swen90013-2018-pl/server) Open the project in Unity.The Unity application will communicate with the local server","title":"2.2.3 Run"},{"location":"#23-deployment-for-development","text":"Follow the steps to setup the local server in 2.2 Build the project from the File menu in Unity Be sure to include all scenes in the build","title":"2.3 Deployment (For Development)"},{"location":"#3-using-the-system","text":"Click the Help link from inside the visualiser. Alternatively, view the html for the user manual at server/UserManual.html .","title":"3. Using the system"},{"location":"#4-extending-the-system","text":"Planning Visualiser is modular and can be extended in multiple ways. Many simple domains can be captured in the existing Animation Profile language. For more complex domains, modifications may need to be made to the application. These are detailed in 4.3. and 4.4","title":"4. Extending the system"},{"location":"#42-architecture-overview","text":"","title":"4.2 Architecture overview"},{"location":"#simple-overview","text":"","title":"Simple Overview"},{"location":"#detailed-overview","text":"","title":"Detailed Overview"},{"location":"#43-extending-the-visualisation-file-generator","text":"The Visualisation File Generator (VFG) decides where objects are on the screen and what they look like, based on the three files listed above. Most domain-related modifications to the system should be made to the VFG. For example, a new domain might require objects to be laid out in a manner which is not captured in the existing Animation Profile language. Extending the Visualisation File Generator requires only building the project in Django (see section 2.2). Modifications or extensions of the VFG need only be carried out only on the Django server (not Unity). For information on the VFG, see the file 'VFG Documentation'.","title":"4.3 Extending the Visualisation File Generator"},{"location":"#44-extending-the-visualiser","text":"Modifying the visualiser is only required when the current visualiser cannot adequately render the domain on-screen. It does not concern the logic of object layout. For example, a user might want to extend the Visualiser to support animated sprites. Extending the Visualiser requires building the project in Unity and Django (see section 2.2). Modifications or extensions of the Visualiser need only be carried out on Unity (not Django). For information on the Visualiser, see the file 'Visualiser Documentation'.","title":"4.4 Extending the Visualiser"},{"location":"Deployment_guide/","text":"Software Build and Deployment Document | Version | Author | Date | Comment| | ------------- |:-------------:| -----:|-----:| |0.1 | Gang Chen | 18/09/2018 |Deployment process for Ubuntu server. Ubuntu is one major OS that unimelb uses. | | 0.2 | Gang Chen | 24/09/2018 |The next release of this document will cover Heroku server. | | 0.3 | Hugh Edwards | 7/10/2018 | Convert to Markdown, editing | Purpose This document describes how to build and deploy the Planning Visualisation standalone software. Document Overview This document is organised in the following sections: 0. Requirements: Requirements for deployment 1. Project Repository: Contains information on how the repository is organised. 2. Pre-deployment Process: Details how to build the software from the source code and how to build the other project artefacts. Additional information on the various steps of the build process is also provided as well as a list of all required libraries. 3. Deployment: How to install and run the software, and the system requirements. 4. Post-deployment: Details how to display the final product. 0. Requirements Build Agent Requirement Your build agent will need to meeting the following minimum requirements. GPU is a must as you will need a valid graphic card and graphic card drive to activate Unity: Components Minimum Requirement Operating System OS: Windows 7 SP1+, 8, 10, 64-bit versions only; macOS 10.11+. Server versions of Windows & OS X are not tested. CPU CPU: SSE2 instruction set support. GPU GPU: Graphics card with DX10 (shader model 4.0) capabilities. Aditional Platform Development Requirements iOS: Mac computer running minimum macOS 10.12.6 and Xcode 9.0 or higher. Android: Android SDK and Java Development Kit (JDK); IL2CPP scripting backend requires Android NDK. Universal Windows Platform: Windows 10 (64-bit), Visual Studio 2015 with C++ Tools component or later and Windows 10 SDK Deployment Server Requirement The deployment server used in developnet is a Linux OS family member - Ubuntu. This section covers the minimum hardware requirements for these deployment servers. Ubuntu Desktop Edition Processor: 2 GHz dual core processor RAM: 2 GiB RAM (system memory) Storage: 25 GB of hard-drive space (or USB stick, memory card or external drive but see LiveCD for an alternative approach) Display: VGA capable of 1024x768 screen resolution (Optional) Accessories: Internet access Port Selection: * 22/tcp open ssh * 80/tcp open http * 631/tcp open ipp * 3306/tcp open mysql * 8000/tcp open http-alt Ubuntu Server Edition Processor: 300 MHz x86 processor RAM: 256 MiB of system memory (RAM) Storage: 1.5 GB of disk space Display: Graphics card and monitor capable of 640x480 (Optional) Accessories: Internet access Port Selection: * 22/tcp open ssh * 80/tcp open http * 631/tcp open ipp * 3306/tcp open mysql * 8000/tcp open http-alt 1.Project Repository The source code and related artefacts are hosted at Bitbucket server, the entire repository can be cloned through the following command: sudo git clone [https://bitbucket.cis.unimelb.edu.au:8445/scm/swen90013/swen90013-2018-pl](https://bitbucket.cis.unimelb.edu.au:8445/scm/swen90013/swen90013-2018-pl) After having successfully cloned the project, move to the current master branch to verify our latest released version with: sudo git checkout master This is equivalent to our latest release branch: sudo git checkout release-sprint3 2.Pre-deployment Process Planning Visualisation\u2019s presentation layer is based on WebGL and Unity, the contents of which can be generated from the Unity part of the repository. This section covers how and what to generate: 2.1 Install Unity Dependencies Install the Version 2018.2.1f1 from https://unity3d.com/ , when installing, select \"Include WebGL\u201d. Additionally, download the followings for building Unity files (This requires roughly 50MB storage space). sudo apt-get install -y libgconf-2-4 sudo apt install libcanberrra-gtk\\* 2.2 Build Unity Project The build process is designed to be cross-platform and self-contained. What all this means is that you can run the various build tasks on any machine where a validated Unity is available, without having to worry about resolving other library dependencies. The Unity project can either be built from the Unity command line, or from the Unity GUI. 2.2.1 Building from command line To build from the command line, enter the following command. We illustrate the idea with Ubuntu build agent. However, the idea can apply to any OS. Move to the /PlanningVisualise directory in the repository that you\u2019ve just checked out from Section 1 and from there type, at the command prompt: /home/$USER/Editor/Unity -batchmode -quit -projectPath \u201cProjectPath\u201d -executeMethod buildscript.build -logFile stdout.log You will need to replace the \u201cProjectPath\u201d with the absolute path of your cloned copy of the repository. E.g. \u201c/home/$USER/swen90013-2018-pl /PlanningVisualise \u201d You will need to replace \u201c/home/$USER/Editor/Unity\u201d with the absolute path of Unity executable on your build agent. Compilation progress can be found in \u201cstdout.log\u201d. For more information on each of the components in the command, please visit https://docs.unity3d.com/Manual/CommandLineArguments.html Should you wish to update the User Interface of this application, you need to include all your customised Unity scenes in the buildscript prior to compilation, buildscript can be found: ../swen90013-2018-pl/PlanningVisualise/Assets/Editor/buildscript.cs With having the command executed, a folder called \u201cbuildweb\u201d should appear under the /PlanningVisualise directory and this will be the final animation contents for the deployment process in Section 3. 2.1 Install Python3 Dependencies Should you wish to change the server side of the repository, you will need to install the following libraries in order to compile the python files with Python3 Interpreter, Python3 Interpreter can be downloaded with : sudo apt-get update sudo apt-get install python3.6 Addition libraries include: sudo apt-get install python-pip sudo pip install numpy scipy**3\\. 2.2.1 Building from Unity GUI Open Unity Click File -> Build Settings Choose 'WebGL' Make sure all the selected scenes are those under the 'Visualisation' folder Click 'Player Settings' Click 'Publishing Settings' Enter 512 for 'WebGL Memory Size' Tick 'WebAssembly' Click 'Build' Ubuntu Deployment Process Installing and running Planning Visualisation is very easy: drop the distribution directory somewhere on your filesystem and run your servers! This section details all this more precisely. An obvious set of pre-requisites is Apache server and Django Server. 3.1 Apache Web Server Installation For Ubuntu server, run the following commands to install Apache server: ``` sudo apt-get update && sudo apt-get upgrade sudo apt-get install apache2 apache2-doc apache2-utils After having successfully installed the Apache server, you can run the server with the following command: sudo service apache2 start **3.1 Apache Web Server Deployment** With the command provided in section 2, you should be able to get a folder called \u201cbuildweb\u201d under \u201c../swen90013-2018-pl/PlanningVisualise/\u201d. The remaining is easy: drop the distribution directory to the designated Apache source folder and restart your apache server: * Move all the files and subdirectories under \u201cbuildweb\u201d to \u201c/var/www/html/\u201c * Restart the apache server with ```\u201csudo service apache2 restart\u201d``` **3.2 Django Server Installation** For Ubuntu server, run the following commands to install Django server: sudo apt install python3-pip pip3 install djangorestframework sudo apt-get install python3-django sudo apt-get install gunicorn3 **3.2 Django Server Deployment** Once the installation is done and the Django server is ready, move to the **_/server_** directory and from there type, at the command prompt: sudo gunicorn3 -b 0.0.0.0:8000 server.wsgi \u2014reload After all, the server should be reachable from external network and your project should be ready. **4. Post-deployment** Planning Visualisation can then be accessed within any web browser that is compatible with WebGL by typing the IP address of you deployment server. **5. Heroku Deployment** **5.1 Pre-deployment Process** Please make sure your setup has met the following conditions: * a free [Heroku account](https://signup.heroku.com/signup/dc). * Python version 3.6 installed locally - see the installation guides for [OS X](http://docs.python-guide.org/en/latest/starting/install3/osx/), [Windows](http://docs.python-guide.org/en/latest/starting/install3/win/), and [Linux](http://docs.python-guide.org/en/latest/starting/install3/linux/). * [Pipenv installed](http://docs.python-guide.org/en/latest/dev/virtualenvs/) locally. Accomplish this by running pip install pipenv. * [Postgres installed](https://devcenter.heroku.com/articles/heroku-postgresql#local-setup) locally, if running the app locally. **5.2 Deployment Process** Heroku Command Line Interface (CLI) - Once installed, you can use the HEROKU command from your command shell. To log in with your Heroku account: heroku login Enter your Heroku credentials. //Email: user@example.com //Password: To clone your project with: git clone https://github.com/heroku/python-getting-started.git cd python-getting-started Next, create an app on Heroku, which prepares Heroku to receive your source code: heroku create When you create an app, a git remote (called heroku) is also created and associated with your local git repository. Heroku generates a random name (in this case lit-bastion-5032) for your app, or you can pass a parameter to specify your own app name. Now deploy your code: git push heroku master Use a [Procfile](https://devcenter.heroku.com/articles/procfile) to explicitly declare what command should be executed to start your app. The Procfile in the example app you deployed looks like this: web: gunicorn gettingstarted.wsgi --log-file - ``` This declares a single process type, web, and the command needed to run it. The name web is important here. It declares that this process type will be attached to the HTTP routing stack of Heroku, and receive web traffic when deployed. Procfiles can contain additional process types. For example, you might declare one for a background worker process that processes items off of a queue. 5.3 Unity with Heroku Deployment When deploying the Django server with Heroku, you will also need to make sure to redirect the traffic for your local server to Heroku within Unity, this can be done by simply enabling and changing the settings in ScenesCoordinator.cs: As shown above in the picture, the current setting is pointing to local machine. Enabling the line below will redirect the data stream to your Heroku server. You should replace \u201c https://immense-bastion-42146.herokuapp.com/upload/pddl \u201d with your Heroku application.","title":"Deployment"},{"location":"VFG_guide/","text":"1 Purpose This document explains the functioning of the Visualisation File Generator (VFG) for the purposes of development. For deployment and the user guide, see README.md. The VFG decides where objects are on the screen and what they look like. Most domain-related modifications to the system should be made to the VFG. For example, a new domain might require objects to be laid out in a manner which is not captured in the existing Animation Profile language. Extending the Visualisation File Generator requires only building the project in Django (see section 2.2 of README.md). Modifications or extensions of the VFG need only be carried out only on the Django server (not Unity). 2 Getting Started To build the VFG, see README.md 3 Overview Input files: Domain PDDL file Problem PDDL file Animation Profile Output file: Visualisation file Overall Architecture: 4 Components 4.1 Parser Here is the code structure of parser. The Parser component gets domain PDDL file, problem PDDL file, animation PDDL file and plan PDDL file and parsers these files into predicates list and animation profile json to feed Solver component . 4.1.1 Plan_generator.py Send domain file and problem file to planning.domain API and gets the solution file. def get_plan(domain_file, problem_file): This function will send the domain and problem pddl file to the planning.domain API to get the plan 4.1.2 Domain_parser.py Transfer domain file into a list of predicates and record all possible predicates in this domain. def get_domain_json(file_name): This function transfers domain file to a list of predicates. Regular expression is used to get the result. Here is an example of the output : { \"on\": 2, \"on-table\": 1, \"clear\": 1, \"arm-free\": 0, \"holding\": 1 } 4.1.3 Problem_parser.py Interprete problem file and get all predicates for INIT and GOAL stages def get_object_list(predicates_lists,str_init): This function gets object list of the domain from predicate list def get_regex_list(predicates_lists): This function changes the format of predicate list def get_problem_json(file_name, predicates_lists): This function parse the problem PDDL file and get the initial predicates and goal predicates. Here is an example of the output : [{ \"init\": [{ \"name\": \"on\", \"objectNames\": [\"c\", \"b\"] }, { \"name\": \"on-table\", \"objectNames\": [\"a\"] }, { \"name\": \"on-table\", \"objectNames\": [\"b\"] }, { \"name\": \"on-table\", \"objectNames\": [\"d\"] }, { \"name\": \"clear\", \"objectNames\": [\"a\"] }, { \"name\": \"clear\", \"objectNames\": [\"c\"] }, { \"name\": \"clear\", \"objectNames\": [\"d\"] }, { \"name\": \"arm-free\", \"objectNames\": [\"No objects\"] }] }, { \"goal\": [{ \"name\": \"on\", \"objectNames\": [\"a\", \"b\"] }, { \"name\": \"on\", \"objectNames\": [\"b\", \"c\"] }, { \"name\": \"on\", \"objectNames\": [\"c\", \"d\"] }], \"goal-condition\": [\"and\"] }] 4.1.4 Predicates_generator.py Interpret solution file and get all predicates for every stage in solution file. def remove_unused_char(action_list): This function removes all the useless characters from solution file. def get_action_name(current_step): This function returns the action name of the current step. def get_stages(plan, problem_dic, problem_file, predicates_list): This function gets the predicates for each stage. Output of Parser: Predicate List of all stages 1. Description The predicate list is generated by Parser Component and feeds Solver Component . It includes all the predicates for each stage and the object list for the problem. Using the result of predicate list and animation profile, the solver can apply the one-way constraint solver to calculate the visualisation result. The object list can be used in the initialisation of the solver. 2. Format The format for predicate list and object list is: { \"stages\": [{ --stage list \"items\": [{ -- predicate list in each stage \"name\": , -- predicate rule \"objectNames\": -- objects to be referenced }], \"add\": , -- compared to previous stage, what predicates are added \"remove\": , -- compared to previous stage, what predicates are removed \"stageName\": , -- name of the stage \"stageInfo\": -- stage information } ], \"objects\": -- object list in the problem } 3. Example Here is an example of the predicate list for Blocks domain. { \"stages\": [{ \"items\": [{ \"name\": \"on\", \"objectNames\": [\"c\", \"b\"] }, { \"name\": \"on-table\", \"objectNames\": [\"a\"] }, { \"name\": \"on-table\", \"objectNames\": [\"b\"] }, { \"name\": \"on-table\", \"objectNames\": [\"d\"] }, { \"name\": \"clear\", \"objectNames\": [\"a\"] }, { \"name\": \"clear\", \"objectNames\": [\"c\"] }, { \"name\": \"clear\", \"objectNames\": [\"d\"] }, { \"name\": \"arm-free\", \"objectNames\": [\"No objects\"] }], \"add\": \"\", \"remove\": \"\", \"stageName\": \"Initial Stage\", \"stageInfo\": \"No Step Information\" }, { \"items\": [{ \"name\": \"on-table\", \"objectNames\": [\"a\"] }, { \"name\": \"on-table\", \"objectNames\": [\"b\"] }, { \"name\": \"on-table\", \"objectNames\": [\"d\"] }, { \"name\": \"clear\", \"objectNames\": [\"a\"] }, { \"name\": \"clear\", \"objectNames\": [\"d\"] }, { \"name\": \"clear\", \"objectNames\": [\"b\"] }, { \"name\": \"holding\", \"objectNames\": [\"c\"] }], \"add\": [{ \"name\": \"clear\", \"objectNames\": [\"b\"] }, { \"name\": \"holding\", \"objectNames\": [\"c\"] }], \"remove\": [{ \"name\": \"on\", \"objectNames\": [\"c\", \"b\"] }, { \"name\": \"clear\", \"objectNames\": [\"c\"] }, { \"name\": \"arm-free\", \"objectNames\": [\"No objects\"] }], \"stageName\": \"unstack (c b)\", \"stageInfo\": \"(:action unstack\\r\\n :parameters (c b)\\r\\n :precondition\\r\\n (and\\r\\n (on c b)\\r\\n (clear c)\\r\\n (arm-free)\\r\\n )\\r\\n :effect\\r\\n (and\\r\\n (holding c)\\r\\n (clear b)\\r\\n (not\\r\\n (clear c)\\r\\n )\\r\\n (not\\r\\n (arm-free)\\r\\n )\\r\\n (not\\r\\n (on c b)\\r\\n )\\r\\n )\\r\\n )\" }], \"objects\": [\"b\", \"d\", \"c\", \"a\"] } 4.2 Solver 4.2.1 Overview Here is the code structure of solver. This module will generate the visualisation file by using the predicates of all stages and animation profile. custom_function.py: This module contain all the customer function we designed to help position the objects. initialise.py: This component is used to initialise the environment and objects for Predicate Solver. random_color.py: This function will provide a randomly selected colour for Initialise to use. solver.py: This module will compute the visualisation file by using the stages predicates and animation. This module will generate the visualisation file by using the predicates of all stages and animation profile. Here is the algorithm diagram of our constraint solver: Here is the link for this diagram: https://www.draw.io/#G12sCLukE55c_9VOKCJZqUiMh7OWFeaAXJ For instance, here are the predicates that need to be solved: (On-table a) (On b a) (On c b) In the predicates, the object ahead is the object to be solved and the object behind is the predefined object. To calculate the position of \"c\", we must know the position of \"b\". Similarly, to calculate the position of \"b\", we must know the position of \"a\". From (on-table a), we can know the position of a, so \"b\" is solved and then \"c\" is solved. The diagram below shows how the objects are referenced. 4.2.1 Steps There are 5 main steps in the algorithm of constraint solver: 4.2.1.1 Create an Object Table (initialise.py , random_color.py) def initialise_objects(object_list, animation_profile): This function will initialise objects in the animation profile and use a dictionary to store all the objects and their attributes. In the dictionary, it will store all objects and their attributes, as shown in the table below: prefab name color height width y x showName a Block a \"a\": 1, \"r\": 0.41, \"b\": 0.41, \"g\": 0.55 40 80 false false true Here is a simple example of object dict: \"a\": { \"prefab\": \"Block\", \"name\": \"a\", \"color\": { \"a\": 1, \"r\": 0.41, \"b\": 0.41, \"g\": 0.55 }, \"height\": 40, \"width\": 80, \"y\": false, \"x\": false, \"showName\": true } 4.2.1.2 Separate Each Stage (customer_functions.py, solver.py) def solve_all_stages(stages, objects_dic, predicates_rules, space): This function will seperate each stage in stages list and run through each stage which contains a list of predicates and solve all the predicates. The stages list is like: Stage1: Predicate1, Predicate2, Predicate3,.... Stage2: Predicate1, Predicate3, Predicate3,... ... Here is a simple example of one stage: { \"items\": [ { \"objectNames\": [ \"c\" ], \"name\": \"on-table\" }, { \"objectNames\": [ \"a\" ], \"name\": \"clear\" }, { \"objectNames\": [ \"b\" ], \"name\": \"on-table\" }, { \"objectNames\": [ \"c\", \"a\" ], \"name\": \"on\" } ] } 4.2.1.3 Create Predicate Query (customer_functions.py, solver.py) def solvepredicates(predicates, objects_dic, predicates_rules, space): This function will store all predicates in a query and pop a predicate from predicates list, and try to solve it by calling check_rule_complete and applypredicates function. If it can be solved, then it will be removed from the query, if it can not be solved yet, it will be put back to the predicate list. The function will return true until all predicates are solved. The predicate lists will be separated like: Predicate1, Predicate2, Predicate3,.... If predicate1 is solved then the predicate list will remove predicate1 and start to solve predicate 2: Predicate2, Predicate3,.... If predicate 1 can't be solved, then it will be put back to the query: Predicate2, Predicate3,....Predicate1 4.2.1.4 Check whether predicate can be solved (customer_functions.py, solver.py) def check_rule_complete(predicate, objects_dic, predicates_rules): This function will check whether this predicate can be solved. For example, here is a predicate for object a and c: { \"objectNames\": [ \"c\", \"a\" ], \"name\": \"on\" } The predicate rule is \"on\" and the objects are \"a\" and \"c\". In this predicate, \"a\" is the referenced object, so to define the position of \"c\", we must know the position of \"a\". If a's value has not be defined, the function will return false because this predicate can't be solved for now. 4.2.1.4 Apply Animation Rule (customer_functions.py, solver.py) def applypredicates(predicate,objects_dic,predicates_rules,space): This object will update the value of related object in the object list by applying the animation rule. For example: (on-table a) Using distributex function in the extensions, a's y value is set to 0. a.y = 0 4.3 Adaptor Here is the code structure of adapter. This component transfers the result generated by Predicate Solver into the final visualisation file. def transfer(one_stage, initialobjects, panel_size,shiftx,shifty, padding=20): This function converts the dictionary into the info needed in visualisation file. def get_panel_size(result, padding=20): This function will for loop all the objects in the visualisaiton dictionary, and try to find the max_x and max_y of the panel. For example, .........max_y . . . . . . ........max_x def generate_visualisation_file(result, object_list,animation_profile): def get_visualisation_json(predicates, animation_profile): These functions are the main functions of this module,they will call the other functions to manipulate the visualisation file for the unity visualiser. \"shape\": { \"Block\": { \"prefab\": \"Block\", \"showName\": true, \"x\": false, \"y\": false, \"color\": \"randomcolor\", \"width\": 80, \"height\": 40 }, \"Claw\": { \"prefab\": \"Claw\", \"color\": { \"r\": 0, \"g\": 0, \"b\": 0, \"a\": 1 }, \"showName\": false, \"x\": 230, \"y\": 500, \"width\": 80, \"height\": 40 }, Visualisation File Structure Visualisation Files are in JSON. They contain * a list of visual stages, containing * a list of visual sprites. * Each Visual sprite has a number of properties, outlined below * Stages also contain a name and a list of predicates true at that stage * A table of images (base64) for visualisation * Subgoal map and pool, for displaying data about subgoals An example Visualisation file is shown below. It is for the Blocks domain, and it has only 2 stages. { \"visualStages\": [{ \"visualSprites\": [{ \"prefabImage\": \"Block\", \"showName\": true, \"x\": 100, \"y\": 0, \"color\": { \"r\": 0.8, \"g\": 0.52, \"b\": 0.25, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"b\", \"minX\": 0.207, \"maxX\": 0.345, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 200, \"y\": 0, \"color\": { \"r\": 0.5, \"g\": 1.0, \"b\": 0.83, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"d\", \"minX\": 0.379, \"maxX\": 0.517, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 100, \"y\": 82, \"color\": { \"r\": 1.0, \"g\": 0.76, \"b\": 0.76, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"c\", \"minX\": 0.207, \"maxX\": 0.345, \"minY\": 0.176, \"maxY\": 0.314 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 0, \"y\": 0, \"color\": { \"r\": 1.0, \"g\": 0.76, \"b\": 0.76, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"a\", \"minX\": 0.034, \"maxX\": 0.172, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Claw\", \"color\": { \"r\": 0, \"g\": 0, \"b\": 0, \"a\": 1 }, \"showName\": false, \"x\": 230, \"y\": 500, \"width\": 80, \"height\": 40, \"name\": \"Claw\", \"minX\": 0.431, \"maxX\": 0.569, \"minY\": 0.897, \"maxY\": 0.966 }, { \"prefabImage\": \"Board\", \"color\": { \"r\": 0, \"g\": 0, \"b\": 0, \"a\": 1 }, \"showName\": false, \"x\": 0, \"y\": 0, \"width\": \"panel_size\", \"height\": 5, \"name\": \"Board\", \"minX\": 0.034, \"maxX\": 0.966, \"minY\": 0.034, \"maxY\": 0.043 }], \"stageName\": \"Initial Stage\", \"stageInfo\": \"No Step Information\" }, { \"visualSprites\": [{ \"prefabImage\": \"Block\", \"showName\": true, \"x\": 100, \"y\": 0, \"color\": { \"r\": 0.8, \"g\": 0.52, \"b\": 0.25, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"b\", \"minX\": 0.207, \"maxX\": 0.345, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 200, \"y\": 0, \"color\": { \"r\": 0.5, \"g\": 1.0, \"b\": 0.83, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"d\", \"minX\": 0.379, \"maxX\": 0.517, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 230, \"y\": 440, \"color\": { \"r\": 1.0, \"g\": 0.76, \"b\": 0.76, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"c\", \"minX\": 0.431, \"maxX\": 0.569, \"minY\": 0.793, \"maxY\": 0.931 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 0, \"y\": 0, \"color\": { \"r\": 1.0, \"g\": 0.76, \"b\": 0.76, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"a\", \"minX\": 0.034, \"maxX\": 0.172, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Claw\", \"color\": { \"r\": 0, \"g\": 0, \"b\": 0, \"a\": 1 }, \"showName\": false, \"x\": 230, \"y\": 500, \"width\": 80, \"height\": 40, \"name\": \"Claw\", \"minX\": 0.431, \"maxX\": 0.569, \"minY\": 0.897, \"maxY\": 0.966 }, { \"prefabImage\": \"Board\", \"color\": { \"r\": 0, \"g\": 0, \"b\": 0, \"a\": 1 }, \"showName\": false, \"x\": 0, \"y\": 0, \"width\": \"panel_size\", \"height\": 5, \"name\": \"Board\", \"minX\": 0.034, \"maxX\": 0.966, \"minY\": 0.034, \"maxY\": 0.043 }], \"stageName\": \"unstack (c b)\", \"stageInfo\": \"(:action unstack\\r\\n :parameters (c b)\\r\\n :precondition\\r\\n (and\\r\\n (on c b)\\r\\n (clear c)\\r\\n (arm-free)\\r\\n )\\r\\n :effect\\r\\n (and\\r\\n (holding c)\\r\\n (clear b)\\r\\n (not\\r\\n (clear c)\\r\\n )\\r\\n (not\\r\\n (arm-free)\\r\\n )\\r\\n (not\\r\\n (on c b)\\r\\n )\\r\\n )\\r\\n )\" }], \"subgoalPool\": { \"m_keys\": [\"(on c d )\", \"(on b c )\", \"(on a b )\"], \"m_values\": [ [\"c\", \"d\"], [\"b\", \"c\"], [\"a\", \"b\"] ] }, \"subgoalMap\": { \"m_keys\": [2, 3, 4, 5, 6], \"m_values\": [ [\"(on c d )\"], [\"(on c d )\"], [\"(on c d )\", \"(on b c )\"], [\"(on c d )\", \"(on b c )\"], [\"(on c d )\", \"(on b c )\", \"(on a b )\"] ] }, \"transferType\": 1, \"imageTable\": { \"m_keys\": [\"Block\", \"Board\", \"Claw\"], \"m_values\": [\"iVB...QmCC\", \"iVBORw0...QmCC\", \"iVB...CYII=\"] } }","title":"VFG"},{"location":"VFG_guide/#1-purpose","text":"This document explains the functioning of the Visualisation File Generator (VFG) for the purposes of development. For deployment and the user guide, see README.md. The VFG decides where objects are on the screen and what they look like. Most domain-related modifications to the system should be made to the VFG. For example, a new domain might require objects to be laid out in a manner which is not captured in the existing Animation Profile language. Extending the Visualisation File Generator requires only building the project in Django (see section 2.2 of README.md). Modifications or extensions of the VFG need only be carried out only on the Django server (not Unity).","title":"1 Purpose"},{"location":"VFG_guide/#2-getting-started","text":"To build the VFG, see README.md","title":"2 Getting Started"},{"location":"VFG_guide/#3-overview","text":"","title":"3 Overview"},{"location":"VFG_guide/#input-files","text":"Domain PDDL file Problem PDDL file Animation Profile","title":"Input files:"},{"location":"VFG_guide/#output-file","text":"Visualisation file","title":"Output file:"},{"location":"VFG_guide/#overall-architecture","text":"","title":"Overall Architecture:"},{"location":"VFG_guide/#4-components","text":"","title":"4 Components"},{"location":"VFG_guide/#41-parser","text":"Here is the code structure of parser. The Parser component gets domain PDDL file, problem PDDL file, animation PDDL file and plan PDDL file and parsers these files into predicates list and animation profile json to feed Solver component .","title":"4.1 Parser"},{"location":"VFG_guide/#411-plan_generatorpy","text":"Send domain file and problem file to planning.domain API and gets the solution file. def get_plan(domain_file, problem_file): This function will send the domain and problem pddl file to the planning.domain API to get the plan","title":"4.1.1 Plan_generator.py"},{"location":"VFG_guide/#412-domain_parserpy","text":"Transfer domain file into a list of predicates and record all possible predicates in this domain. def get_domain_json(file_name): This function transfers domain file to a list of predicates. Regular expression is used to get the result. Here is an example of the output : { \"on\": 2, \"on-table\": 1, \"clear\": 1, \"arm-free\": 0, \"holding\": 1 }","title":"4.1.2 Domain_parser.py"},{"location":"VFG_guide/#413-problem_parserpy","text":"Interprete problem file and get all predicates for INIT and GOAL stages def get_object_list(predicates_lists,str_init): This function gets object list of the domain from predicate list def get_regex_list(predicates_lists): This function changes the format of predicate list def get_problem_json(file_name, predicates_lists): This function parse the problem PDDL file and get the initial predicates and goal predicates. Here is an example of the output : [{ \"init\": [{ \"name\": \"on\", \"objectNames\": [\"c\", \"b\"] }, { \"name\": \"on-table\", \"objectNames\": [\"a\"] }, { \"name\": \"on-table\", \"objectNames\": [\"b\"] }, { \"name\": \"on-table\", \"objectNames\": [\"d\"] }, { \"name\": \"clear\", \"objectNames\": [\"a\"] }, { \"name\": \"clear\", \"objectNames\": [\"c\"] }, { \"name\": \"clear\", \"objectNames\": [\"d\"] }, { \"name\": \"arm-free\", \"objectNames\": [\"No objects\"] }] }, { \"goal\": [{ \"name\": \"on\", \"objectNames\": [\"a\", \"b\"] }, { \"name\": \"on\", \"objectNames\": [\"b\", \"c\"] }, { \"name\": \"on\", \"objectNames\": [\"c\", \"d\"] }], \"goal-condition\": [\"and\"] }]","title":"4.1.3 Problem_parser.py"},{"location":"VFG_guide/#414-predicates_generatorpy","text":"Interpret solution file and get all predicates for every stage in solution file. def remove_unused_char(action_list): This function removes all the useless characters from solution file. def get_action_name(current_step): This function returns the action name of the current step. def get_stages(plan, problem_dic, problem_file, predicates_list): This function gets the predicates for each stage.","title":"4.1.4 Predicates_generator.py"},{"location":"VFG_guide/#output-of-parser-predicate-list-of-all-stages","text":"","title":"Output of Parser: Predicate List of all stages"},{"location":"VFG_guide/#1-description","text":"The predicate list is generated by Parser Component and feeds Solver Component . It includes all the predicates for each stage and the object list for the problem. Using the result of predicate list and animation profile, the solver can apply the one-way constraint solver to calculate the visualisation result. The object list can be used in the initialisation of the solver.","title":"1. Description"},{"location":"VFG_guide/#2-format","text":"The format for predicate list and object list is: { \"stages\": [{ --stage list \"items\": [{ -- predicate list in each stage \"name\": , -- predicate rule \"objectNames\": -- objects to be referenced }], \"add\": , -- compared to previous stage, what predicates are added \"remove\": , -- compared to previous stage, what predicates are removed \"stageName\": , -- name of the stage \"stageInfo\": -- stage information } ], \"objects\": -- object list in the problem }","title":"2. Format"},{"location":"VFG_guide/#3-example","text":"Here is an example of the predicate list for Blocks domain. { \"stages\": [{ \"items\": [{ \"name\": \"on\", \"objectNames\": [\"c\", \"b\"] }, { \"name\": \"on-table\", \"objectNames\": [\"a\"] }, { \"name\": \"on-table\", \"objectNames\": [\"b\"] }, { \"name\": \"on-table\", \"objectNames\": [\"d\"] }, { \"name\": \"clear\", \"objectNames\": [\"a\"] }, { \"name\": \"clear\", \"objectNames\": [\"c\"] }, { \"name\": \"clear\", \"objectNames\": [\"d\"] }, { \"name\": \"arm-free\", \"objectNames\": [\"No objects\"] }], \"add\": \"\", \"remove\": \"\", \"stageName\": \"Initial Stage\", \"stageInfo\": \"No Step Information\" }, { \"items\": [{ \"name\": \"on-table\", \"objectNames\": [\"a\"] }, { \"name\": \"on-table\", \"objectNames\": [\"b\"] }, { \"name\": \"on-table\", \"objectNames\": [\"d\"] }, { \"name\": \"clear\", \"objectNames\": [\"a\"] }, { \"name\": \"clear\", \"objectNames\": [\"d\"] }, { \"name\": \"clear\", \"objectNames\": [\"b\"] }, { \"name\": \"holding\", \"objectNames\": [\"c\"] }], \"add\": [{ \"name\": \"clear\", \"objectNames\": [\"b\"] }, { \"name\": \"holding\", \"objectNames\": [\"c\"] }], \"remove\": [{ \"name\": \"on\", \"objectNames\": [\"c\", \"b\"] }, { \"name\": \"clear\", \"objectNames\": [\"c\"] }, { \"name\": \"arm-free\", \"objectNames\": [\"No objects\"] }], \"stageName\": \"unstack (c b)\", \"stageInfo\": \"(:action unstack\\r\\n :parameters (c b)\\r\\n :precondition\\r\\n (and\\r\\n (on c b)\\r\\n (clear c)\\r\\n (arm-free)\\r\\n )\\r\\n :effect\\r\\n (and\\r\\n (holding c)\\r\\n (clear b)\\r\\n (not\\r\\n (clear c)\\r\\n )\\r\\n (not\\r\\n (arm-free)\\r\\n )\\r\\n (not\\r\\n (on c b)\\r\\n )\\r\\n )\\r\\n )\" }], \"objects\": [\"b\", \"d\", \"c\", \"a\"] }","title":"3. Example"},{"location":"VFG_guide/#42-solver","text":"","title":"4.2 Solver"},{"location":"VFG_guide/#421-overview","text":"Here is the code structure of solver. This module will generate the visualisation file by using the predicates of all stages and animation profile. custom_function.py: This module contain all the customer function we designed to help position the objects. initialise.py: This component is used to initialise the environment and objects for Predicate Solver. random_color.py: This function will provide a randomly selected colour for Initialise to use. solver.py: This module will compute the visualisation file by using the stages predicates and animation. This module will generate the visualisation file by using the predicates of all stages and animation profile. Here is the algorithm diagram of our constraint solver: Here is the link for this diagram: https://www.draw.io/#G12sCLukE55c_9VOKCJZqUiMh7OWFeaAXJ For instance, here are the predicates that need to be solved: (On-table a) (On b a) (On c b) In the predicates, the object ahead is the object to be solved and the object behind is the predefined object. To calculate the position of \"c\", we must know the position of \"b\". Similarly, to calculate the position of \"b\", we must know the position of \"a\". From (on-table a), we can know the position of a, so \"b\" is solved and then \"c\" is solved. The diagram below shows how the objects are referenced.","title":"4.2.1 Overview"},{"location":"VFG_guide/#421-steps","text":"There are 5 main steps in the algorithm of constraint solver:","title":"4.2.1 Steps"},{"location":"VFG_guide/#4211-create-an-object-table-initialisepy-random_colorpy","text":"def initialise_objects(object_list, animation_profile): This function will initialise objects in the animation profile and use a dictionary to store all the objects and their attributes. In the dictionary, it will store all objects and their attributes, as shown in the table below: prefab name color height width y x showName a Block a \"a\": 1, \"r\": 0.41, \"b\": 0.41, \"g\": 0.55 40 80 false false true Here is a simple example of object dict: \"a\": { \"prefab\": \"Block\", \"name\": \"a\", \"color\": { \"a\": 1, \"r\": 0.41, \"b\": 0.41, \"g\": 0.55 }, \"height\": 40, \"width\": 80, \"y\": false, \"x\": false, \"showName\": true }","title":"4.2.1.1 Create an Object Table (initialise.py , random_color.py)"},{"location":"VFG_guide/#4212-separate-each-stage-customer_functionspy-solverpy","text":"def solve_all_stages(stages, objects_dic, predicates_rules, space): This function will seperate each stage in stages list and run through each stage which contains a list of predicates and solve all the predicates. The stages list is like: Stage1: Predicate1, Predicate2, Predicate3,.... Stage2: Predicate1, Predicate3, Predicate3,... ... Here is a simple example of one stage: { \"items\": [ { \"objectNames\": [ \"c\" ], \"name\": \"on-table\" }, { \"objectNames\": [ \"a\" ], \"name\": \"clear\" }, { \"objectNames\": [ \"b\" ], \"name\": \"on-table\" }, { \"objectNames\": [ \"c\", \"a\" ], \"name\": \"on\" } ] }","title":"4.2.1.2 Separate Each Stage (customer_functions.py, solver.py)"},{"location":"VFG_guide/#4213-create-predicate-query-customer_functionspy-solverpy","text":"def solvepredicates(predicates, objects_dic, predicates_rules, space): This function will store all predicates in a query and pop a predicate from predicates list, and try to solve it by calling check_rule_complete and applypredicates function. If it can be solved, then it will be removed from the query, if it can not be solved yet, it will be put back to the predicate list. The function will return true until all predicates are solved. The predicate lists will be separated like: Predicate1, Predicate2, Predicate3,.... If predicate1 is solved then the predicate list will remove predicate1 and start to solve predicate 2: Predicate2, Predicate3,.... If predicate 1 can't be solved, then it will be put back to the query: Predicate2, Predicate3,....Predicate1","title":"4.2.1.3 Create Predicate Query (customer_functions.py, solver.py)"},{"location":"VFG_guide/#4214-check-whether-predicate-can-be-solved-customer_functionspy-solverpy","text":"def check_rule_complete(predicate, objects_dic, predicates_rules): This function will check whether this predicate can be solved. For example, here is a predicate for object a and c: { \"objectNames\": [ \"c\", \"a\" ], \"name\": \"on\" } The predicate rule is \"on\" and the objects are \"a\" and \"c\". In this predicate, \"a\" is the referenced object, so to define the position of \"c\", we must know the position of \"a\". If a's value has not be defined, the function will return false because this predicate can't be solved for now.","title":"4.2.1.4 Check whether predicate can be solved (customer_functions.py, solver.py)"},{"location":"VFG_guide/#4214-apply-animation-rule-customer_functionspy-solverpy","text":"def applypredicates(predicate,objects_dic,predicates_rules,space): This object will update the value of related object in the object list by applying the animation rule. For example: (on-table a) Using distributex function in the extensions, a's y value is set to 0. a.y = 0","title":"4.2.1.4 Apply Animation Rule (customer_functions.py, solver.py)"},{"location":"VFG_guide/#43-adaptor","text":"Here is the code structure of adapter. This component transfers the result generated by Predicate Solver into the final visualisation file. def transfer(one_stage, initialobjects, panel_size,shiftx,shifty, padding=20): This function converts the dictionary into the info needed in visualisation file. def get_panel_size(result, padding=20): This function will for loop all the objects in the visualisaiton dictionary, and try to find the max_x and max_y of the panel. For example, .........max_y . . . . . . ........max_x def generate_visualisation_file(result, object_list,animation_profile): def get_visualisation_json(predicates, animation_profile): These functions are the main functions of this module,they will call the other functions to manipulate the visualisation file for the unity visualiser. \"shape\": { \"Block\": { \"prefab\": \"Block\", \"showName\": true, \"x\": false, \"y\": false, \"color\": \"randomcolor\", \"width\": 80, \"height\": 40 }, \"Claw\": { \"prefab\": \"Claw\", \"color\": { \"r\": 0, \"g\": 0, \"b\": 0, \"a\": 1 }, \"showName\": false, \"x\": 230, \"y\": 500, \"width\": 80, \"height\": 40 },","title":"4.3 Adaptor"},{"location":"VFG_guide/#visualisation-file-structure","text":"Visualisation Files are in JSON. They contain * a list of visual stages, containing * a list of visual sprites. * Each Visual sprite has a number of properties, outlined below * Stages also contain a name and a list of predicates true at that stage * A table of images (base64) for visualisation * Subgoal map and pool, for displaying data about subgoals An example Visualisation file is shown below. It is for the Blocks domain, and it has only 2 stages. { \"visualStages\": [{ \"visualSprites\": [{ \"prefabImage\": \"Block\", \"showName\": true, \"x\": 100, \"y\": 0, \"color\": { \"r\": 0.8, \"g\": 0.52, \"b\": 0.25, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"b\", \"minX\": 0.207, \"maxX\": 0.345, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 200, \"y\": 0, \"color\": { \"r\": 0.5, \"g\": 1.0, \"b\": 0.83, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"d\", \"minX\": 0.379, \"maxX\": 0.517, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 100, \"y\": 82, \"color\": { \"r\": 1.0, \"g\": 0.76, \"b\": 0.76, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"c\", \"minX\": 0.207, \"maxX\": 0.345, \"minY\": 0.176, \"maxY\": 0.314 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 0, \"y\": 0, \"color\": { \"r\": 1.0, \"g\": 0.76, \"b\": 0.76, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"a\", \"minX\": 0.034, \"maxX\": 0.172, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Claw\", \"color\": { \"r\": 0, \"g\": 0, \"b\": 0, \"a\": 1 }, \"showName\": false, \"x\": 230, \"y\": 500, \"width\": 80, \"height\": 40, \"name\": \"Claw\", \"minX\": 0.431, \"maxX\": 0.569, \"minY\": 0.897, \"maxY\": 0.966 }, { \"prefabImage\": \"Board\", \"color\": { \"r\": 0, \"g\": 0, \"b\": 0, \"a\": 1 }, \"showName\": false, \"x\": 0, \"y\": 0, \"width\": \"panel_size\", \"height\": 5, \"name\": \"Board\", \"minX\": 0.034, \"maxX\": 0.966, \"minY\": 0.034, \"maxY\": 0.043 }], \"stageName\": \"Initial Stage\", \"stageInfo\": \"No Step Information\" }, { \"visualSprites\": [{ \"prefabImage\": \"Block\", \"showName\": true, \"x\": 100, \"y\": 0, \"color\": { \"r\": 0.8, \"g\": 0.52, \"b\": 0.25, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"b\", \"minX\": 0.207, \"maxX\": 0.345, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 200, \"y\": 0, \"color\": { \"r\": 0.5, \"g\": 1.0, \"b\": 0.83, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"d\", \"minX\": 0.379, \"maxX\": 0.517, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 230, \"y\": 440, \"color\": { \"r\": 1.0, \"g\": 0.76, \"b\": 0.76, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"c\", \"minX\": 0.431, \"maxX\": 0.569, \"minY\": 0.793, \"maxY\": 0.931 }, { \"prefabImage\": \"Block\", \"showName\": true, \"x\": 0, \"y\": 0, \"color\": { \"r\": 1.0, \"g\": 0.76, \"b\": 0.76, \"a\": 1.0 }, \"width\": 80, \"height\": 80, \"name\": \"a\", \"minX\": 0.034, \"maxX\": 0.172, \"minY\": 0.034, \"maxY\": 0.172 }, { \"prefabImage\": \"Claw\", \"color\": { \"r\": 0, \"g\": 0, \"b\": 0, \"a\": 1 }, \"showName\": false, \"x\": 230, \"y\": 500, \"width\": 80, \"height\": 40, \"name\": \"Claw\", \"minX\": 0.431, \"maxX\": 0.569, \"minY\": 0.897, \"maxY\": 0.966 }, { \"prefabImage\": \"Board\", \"color\": { \"r\": 0, \"g\": 0, \"b\": 0, \"a\": 1 }, \"showName\": false, \"x\": 0, \"y\": 0, \"width\": \"panel_size\", \"height\": 5, \"name\": \"Board\", \"minX\": 0.034, \"maxX\": 0.966, \"minY\": 0.034, \"maxY\": 0.043 }], \"stageName\": \"unstack (c b)\", \"stageInfo\": \"(:action unstack\\r\\n :parameters (c b)\\r\\n :precondition\\r\\n (and\\r\\n (on c b)\\r\\n (clear c)\\r\\n (arm-free)\\r\\n )\\r\\n :effect\\r\\n (and\\r\\n (holding c)\\r\\n (clear b)\\r\\n (not\\r\\n (clear c)\\r\\n )\\r\\n (not\\r\\n (arm-free)\\r\\n )\\r\\n (not\\r\\n (on c b)\\r\\n )\\r\\n )\\r\\n )\" }], \"subgoalPool\": { \"m_keys\": [\"(on c d )\", \"(on b c )\", \"(on a b )\"], \"m_values\": [ [\"c\", \"d\"], [\"b\", \"c\"], [\"a\", \"b\"] ] }, \"subgoalMap\": { \"m_keys\": [2, 3, 4, 5, 6], \"m_values\": [ [\"(on c d )\"], [\"(on c d )\"], [\"(on c d )\", \"(on b c )\"], [\"(on c d )\", \"(on b c )\"], [\"(on c d )\", \"(on b c )\", \"(on a b )\"] ] }, \"transferType\": 1, \"imageTable\": { \"m_keys\": [\"Block\", \"Board\", \"Claw\"], \"m_values\": [\"iVB...QmCC\", \"iVBORw0...QmCC\", \"iVB...CYII=\"] } }","title":"Visualisation File Structure"},{"location":"Visualiser_guide/","text":"1 Purpose The Visualiser takes a Visualisation File and displays an animation to the user. It is a Unity architecture. Modifying the visualiser is only required when the current visualiser cannot adequately render the domain on-screen. It does not concern the logic of object layout. For example, a user might want to extend the Visualiser to support animated sprites. Extending the Visualiser requires building the project in Unity and Django (see section 2.2 of README.md). Modifications or extensions of the Visualiser need only be carried out on Unity (not Django). For information on the Visualiser, see the file 'Visualiser Documentation'. 2 Getting started 2.1 Installation Install Unity (See README.md) 2.2 Usage See the User Manual, which is accessible from within the application, or with the file User Manual.html . 2.3 Development The visualizer will takes the visualization file generated by the visualization file generator. The visualizer will automatically analyze the visualization file and transfer the JSON data into a few Unity prefabs and display them on the screen. 2.3.1 Editing Scenes Open Planning Visualisation folder as an Unity workspace. Drag scenes file to the Hierarchy to start editing the GameObjects in the scene, Scene files are under the Scene folders in the AnimationProfile and Visualier folders. 2.3.2 Editing Scripts Script can be created directly in the Assets directories, simply right click Create -> C# Script. If scripts are going to be attached to a game object, the class should be extending MonoBehaviour. Unity would recommend using their monoDeveloper to code for the guideword when using Unity.Engine. 2.3.3 How to Run Put only the scene you want to test in the Hierarchy and press the play button at the top. 2.3.4 Building WebGL After Selecting all the scene with the starting Scene being the first one clicked There is a WebGL module that need to be installed, open the installer again and tick only the WebGL module to be installed. After the module is loaded, in Files -> Build Setting, select WebGL and click Player Setting, the inspector on your right will show the setting of the web player, select the NewTemplate as our template, and click Build and Run in the Build Setting window and select the Built file location. This may take a while, after it is finished, the Browser will open the First Scene of the project. Later, unless we have a new built, we can go to the directory of the built and open the index.html. Notice that Chrome will not allowed to open html file locally, so better to set up a server or using other Browser to open the index.html. 3 Architecture Overview Input: a visualisation file. The visualisation file is a generic JSON file generated by the VFG, demonstrating how shapes are to be drawn on the screen in stages. The structure of the Visualisation File is outlined in the VFG Documentation file. Output: a visualisation of the visualisation file Architectural design: Directory Structure +---Visualiser | +---Animations | +---Fonts | +---Images | +---Resources | +---Scenes | +---Scripts | | +---FileUpload | | \\---Visualisation | | +---AnimationControl | | +---TransferPack | | \\---VisualisationModels | \\---Sprites \\---WebGLTemplates \\---NewTemplate The input of the visualizer is the visualization file. The visualization file is parsed into a local object with the following structure: // Solution - Wraps all stages as a whole solution public class VisualSolutionObject { public VisualStageObject[] visualStages; public int transferType; public Dictionary<string, string> imageTable; public int numberOfStages; public Color highlightColor; } // Stage - Contains all sprites in this stage public class VisualStageObject { public VisualSpriteObject[] visualSprites; public string stageName; public string stageInfo; } // Sprite - Presents any visual object drawn on the screen public class VisualSpriteObject { public string name; public string prefabImage; public Color color; public bool isShowName; public float minX; public float maxX; public float minY; public float maxY; public int rotation; public int depth; public bool isHighlighted; } 4 Components Components are structure via a number of subdirectories to the Visualiser folder Animations Keeps the files for Unity animations. These files are used to define how prefabs fade-in or fade-out. These files will only be used by the Unity Engine. Fonts Keep the files for Unity fonts. These files are used by the Unity engine to correctly display text. These files will only be used by the Unity Engine. Images Keep the file for UI elements of the visualizer. These files are used to display the \"play\" button or \"pause\" button. Images of the animations are not kept here. Scenes Keep the files of Unity scenes. Sprites Defines the basic prefabs (or sprites) of Unity. Resources Other resources used by the Unity Engine. Scripts C# scripts are kept in this folder. This is what to edit when new features are added to the visualizer. Important Scripts SpriteController.cs SpriteController is the script controls how a visible object is rendered on the screen. This script will generate prefab according to the data in the visualization file. It will also change the size of the prefab to fit the size of the screen. The liner-movement logic is implemented in this script too. VisualiserController.cs SpriteController is the script manages the solution file and all visual objects in each stage. This script keeps all the GameObject as an objects pool. It is also responsible for rendering each step in the solution. 5 Extensions The visualizer is designed as a component that only displays data in the visualization file. Most extensions to Planning Visualiser can be made through the VFG. If new types of animiations need to be supported which cannot be represented in the existing Visualsiation File format: * Define a new object property in the visualization file * Modify the scripts SpriteController.cs and VisualiserController.cs to implement the new object properties","title":"Visualiser"},{"location":"Visualiser_guide/#1-purpose","text":"The Visualiser takes a Visualisation File and displays an animation to the user. It is a Unity architecture. Modifying the visualiser is only required when the current visualiser cannot adequately render the domain on-screen. It does not concern the logic of object layout. For example, a user might want to extend the Visualiser to support animated sprites. Extending the Visualiser requires building the project in Unity and Django (see section 2.2 of README.md). Modifications or extensions of the Visualiser need only be carried out on Unity (not Django). For information on the Visualiser, see the file 'Visualiser Documentation'.","title":"1 Purpose"},{"location":"Visualiser_guide/#2-getting-started","text":"","title":"2 Getting started"},{"location":"Visualiser_guide/#21-installation","text":"Install Unity (See README.md)","title":"2.1 Installation"},{"location":"Visualiser_guide/#22-usage","text":"See the User Manual, which is accessible from within the application, or with the file User Manual.html .","title":"2.2 Usage"},{"location":"Visualiser_guide/#23-development","text":"The visualizer will takes the visualization file generated by the visualization file generator. The visualizer will automatically analyze the visualization file and transfer the JSON data into a few Unity prefabs and display them on the screen.","title":"2.3 Development"},{"location":"Visualiser_guide/#231-editing-scenes","text":"Open Planning Visualisation folder as an Unity workspace. Drag scenes file to the Hierarchy to start editing the GameObjects in the scene, Scene files are under the Scene folders in the AnimationProfile and Visualier folders.","title":"2.3.1 Editing Scenes"},{"location":"Visualiser_guide/#232-editing-scripts","text":"Script can be created directly in the Assets directories, simply right click Create -> C# Script. If scripts are going to be attached to a game object, the class should be extending MonoBehaviour. Unity would recommend using their monoDeveloper to code for the guideword when using Unity.Engine.","title":"2.3.2 Editing Scripts"},{"location":"Visualiser_guide/#233-how-to-run","text":"Put only the scene you want to test in the Hierarchy and press the play button at the top.","title":"2.3.3 How to Run"},{"location":"Visualiser_guide/#234-building-webgl","text":"After Selecting all the scene with the starting Scene being the first one clicked There is a WebGL module that need to be installed, open the installer again and tick only the WebGL module to be installed. After the module is loaded, in Files -> Build Setting, select WebGL and click Player Setting, the inspector on your right will show the setting of the web player, select the NewTemplate as our template, and click Build and Run in the Build Setting window and select the Built file location. This may take a while, after it is finished, the Browser will open the First Scene of the project. Later, unless we have a new built, we can go to the directory of the built and open the index.html. Notice that Chrome will not allowed to open html file locally, so better to set up a server or using other Browser to open the index.html.","title":"2.3.4 Building WebGL"},{"location":"Visualiser_guide/#3-architecture-overview","text":"Input: a visualisation file. The visualisation file is a generic JSON file generated by the VFG, demonstrating how shapes are to be drawn on the screen in stages. The structure of the Visualisation File is outlined in the VFG Documentation file. Output: a visualisation of the visualisation file","title":"3 Architecture Overview"},{"location":"Visualiser_guide/#architectural-design","text":"","title":"Architectural design:"},{"location":"Visualiser_guide/#directory-structure","text":"+---Visualiser | +---Animations | +---Fonts | +---Images | +---Resources | +---Scenes | +---Scripts | | +---FileUpload | | \\---Visualisation | | +---AnimationControl | | +---TransferPack | | \\---VisualisationModels | \\---Sprites \\---WebGLTemplates \\---NewTemplate The input of the visualizer is the visualization file. The visualization file is parsed into a local object with the following structure: // Solution - Wraps all stages as a whole solution public class VisualSolutionObject { public VisualStageObject[] visualStages; public int transferType; public Dictionary<string, string> imageTable; public int numberOfStages; public Color highlightColor; } // Stage - Contains all sprites in this stage public class VisualStageObject { public VisualSpriteObject[] visualSprites; public string stageName; public string stageInfo; } // Sprite - Presents any visual object drawn on the screen public class VisualSpriteObject { public string name; public string prefabImage; public Color color; public bool isShowName; public float minX; public float maxX; public float minY; public float maxY; public int rotation; public int depth; public bool isHighlighted; }","title":"Directory Structure"},{"location":"Visualiser_guide/#4-components","text":"Components are structure via a number of subdirectories to the Visualiser folder","title":"4 Components"},{"location":"Visualiser_guide/#animations","text":"Keeps the files for Unity animations. These files are used to define how prefabs fade-in or fade-out. These files will only be used by the Unity Engine.","title":"Animations"},{"location":"Visualiser_guide/#fonts","text":"Keep the files for Unity fonts. These files are used by the Unity engine to correctly display text. These files will only be used by the Unity Engine.","title":"Fonts"},{"location":"Visualiser_guide/#images","text":"Keep the file for UI elements of the visualizer. These files are used to display the \"play\" button or \"pause\" button. Images of the animations are not kept here.","title":"Images"},{"location":"Visualiser_guide/#scenes","text":"Keep the files of Unity scenes.","title":"Scenes"},{"location":"Visualiser_guide/#sprites","text":"Defines the basic prefabs (or sprites) of Unity.","title":"Sprites"},{"location":"Visualiser_guide/#resources","text":"Other resources used by the Unity Engine.","title":"Resources"},{"location":"Visualiser_guide/#scripts","text":"C# scripts are kept in this folder. This is what to edit when new features are added to the visualizer.","title":"Scripts"},{"location":"Visualiser_guide/#important-scripts","text":"SpriteController.cs SpriteController is the script controls how a visible object is rendered on the screen. This script will generate prefab according to the data in the visualization file. It will also change the size of the prefab to fit the size of the screen. The liner-movement logic is implemented in this script too. VisualiserController.cs SpriteController is the script manages the solution file and all visual objects in each stage. This script keeps all the GameObject as an objects pool. It is also responsible for rendering each step in the solution.","title":"Important Scripts"},{"location":"Visualiser_guide/#5-extensions","text":"The visualizer is designed as a component that only displays data in the visualization file. Most extensions to Planning Visualiser can be made through the VFG. If new types of animiations need to be supported which cannot be represented in the existing Visualsiation File format: * Define a new object property in the visualization file * Modify the scripts SpriteController.cs and VisualiserController.cs to implement the new object properties","title":"5 Extensions"},{"location":"ap_guide/","text":"1 Introduction 1.1 Purpose An Animation Profile (AP) is a user-written PDDL file which tells the Visualiser how a Domain is to be visualised. Each Animation Profile corresponds to one Domain. Essentially, the AP provides a set of visual objects (\"shapes\") within the domain, along with a set of mappings from Predicates to animation behaviours. 1.2 Scope The AP Language is designed to be flexible enough to allow for the animation of many simple PDDL domains, such as those found at https://bitbucket.org/planning-researchers/classical-domains/src/208a850d2ff2a27068329ad578ad99af9ec7e5c5/classical/?at=master. Currently, APs have been written for four domains from this repository: Blocks, Towers of Hanoi, Logistics, and Grid. Other simple domains can be visualised in the language. For more complicated domains, additional functions or object properties may be added (See section 4). 2 Using the Language This section contains complete documentation for the syntax and semantics of the AP language. For a quick starting point to writing your own AP, see section 3. 2.1 Key Components 2.1.1 Predicates The first content of the AP should be the Predicate blocks. Here is an example of a Predicate block. (:predicate holding :parameters (?x claw) :effect ( (equal (?x x y) (claw x y)) ) ) There should be one or zero Predicate blocks for each Predicate in the Domain. If there is no Predicate block for a Predicate in the domain, the Predicate is ignored by the solver. Predicate Blocks contain: * The name of the Predicate, for example holding . * The parameters of the Predicate. Parameters are objects to which the Predicate applies. For example, holding(?x) means that the predicate on-table is true for the object ?x. * The effect of the Predicate. This is a logical statement concerning object properties which holds true when the predicate holds true. For example, (equal (?x x y) (claw x y)) means that the object ?x is at the object claw . * (Optionally) A Priority: * Specifies a priority in which predicates are solved * Example: * :priority 0 * Higher priority predicates are applied first * This is required to ensure a limited number of domains (eg Towers of Hanoi) can be solved. Typically it is required when multiple predicates affect the same variables. 2.1.2 Shapes Shapes are visual objects represented on the screen. An example of a Shape block is: (:shape block :type default :properties( (showname false) (x NULL) (y NULL) (color (function randomcolor)) (width 80) (height 80) (base64image iVBORw0KGg...oAA) ) ) Shape blocks contain: * The name of the shape, for example block * The type of the object. Types can either be default , custom , or predefine . * default objects apply to any objects mentioned in the problem file. A 'block' in the problem file is an example of a default object. * custom objects are additional to the problem file, and are created by the user for visual effect. The 'claw' is an example of a custom object - it mainly serves a visual purpose and is not specified in the problem or domain file. The robot in the Grid domain is another example of a custom object - it is not explicitly mentioned in the domain objects, but its behaviour is still fairly dynamic (moving around etc) * predefine These objects are assigned only to domain objects whose name matches any of the names in the :object field. This is used to apply properties to domain objects with specific naming conventions, for example, key1 , key2 , ... in the Grid domain. * Object properties. These properties govern the position and appearance of the object. See section 2.4 for a detailed list of object properties. 2.2 Syntax 2.2.1 Description The syntax of the language is based on PDDL syntax, which is itself based on Lisp. See Section 2.2.2 for detailed resources on these languages. 2.2.2 Resources PDDL information: https://en.wikipedia.org/wiki/Planning_Domain_Definition_Language PDDL examples, solver: http://planning.domains/ Lisp information: https://en.wikipedia.org/wiki/Lisp_(programming_language) Lisp Tutorial: https://www.tutorialspoint.com/lisp/ 2.3 Types A type is a class of variable to which a property can be assigned. The use of the word 'type' is therefore fairly loose. AP supports a number of 'types': * Integer * Boolean - true or false * Function - Allocates a property based on some function, for example, distribute_horizontal * Color - either a colour constant, eg BLACK , (see below), the RANDOMCOLOR function (see section 2.5), or an rgb value, for example #FAA2B5 * Constant - A number of pre-defined constants exist. These should by convention be written in CAPITALS. * Colours: BLACK, RED, BLUE, GREEN, YELLOW * Integer Constants: PANEL_SIZE * NULL - A NULL value means the user is not specifying the property. NULL properties are typically be set by Predicate rules. A list of the types to which each property can be assigned is in section 2.4. 2.4 Object Properties A number of Object Properties can be assigned for each Shape. * showname (Boolean): whether to display the shape's name on screen * x (Integer): x position of the shape on screen * y (Integer): y position of the shape on screen * colour (Colour): Colour of the shape. Can be a constant (eg BLACK ), an RGB value (eg #FAA2B5 ), or the custom value RANDOMCOLOR which picks a random RGB value. * width (Integer): Width of the object on screen * height: Height of the object on screen * base64image: A Base64 string representing the shape's image. Base64 images can be generated at https://www.base64decode.org/ * depth: Depth of the object on screen. Higher depth objects are drawn behind lower depths. * label: Optional attribute specifying a string label to be drawn on the object. 2.5 Functions Functions have two uses: * In Predicate blocks: here they are 'declarative' in nature and when specified, are true for their parameters * In object properties: Here they return a value (eg random_colour). List of functions: Distribution Distribution functions 'distribute' objects in a certain manner. They are used to lay objects out on the screen. All objects for which the same parameters of 'distribute' are called will be included in the distribution. Distribution works such that objects will be placed in a certain area without overlapping. Between animation frames, objects will not move (unless their positions are reset). distributex This function distributes objects along a horizontal plane. Parameter spacebtwn governs the space between objects Example of use: (assign (?x x) (function distributex (objects ?x) (settings (spacebtwn 40)))) distributey This function distributes objects along a vertical plane. Parameter spacebtwn governs the space between objects Example of use: (assign (?city y) (function distributey (objects ?city))) distribute_grid_around_point This function distributes objects within a grid-like structure Parameter spacebtwn governs the space between objects Example of use: (assign (?p x y) (function distribute_grid_around_point (objects ?p))) distribute_within_objects_vertical This function distributes objects vertically within the bounds of another object. For example, cars can be distributed within a city. Parameter spacebtwn governs the space between objects Example of use: (assign (?r x y) (function distribute_within_objects_vertical (objects ?r ?x)(settings (spacebtw 20)))) distribute_within_objects_horizontal This function distributes objects horizontally within the bounds of another object. For example, cars can be distributed within a city. Example of use: (assign (?obj x) (function distribute_within_objects_horizontal (objects ?obj ?loc))) Other Functions * calculate_label * calculate_label (objects ?obj1 ?obj2)) displays a numeric label for obj1, based on the number of obj2 objects with this function applied to them. For example, if there are 3 instances of calculate label for (a b) (a c) (a d) , then object a will have a label of \"3\". Useful for displaying how many objects are inside another object * Example of use: * (assign (?obj2 label) (function calculate_label (objects ?obj1 ?obj2))) * align_middle * align_middle (objects ?x ?y) aligns objects x to the middle of object y * Example of use: * (assign (?x x) (function align_middle (objects ?x ?y))) * apply_smaller * apply_smaller (objects ?x ?y) sets ?y to be displayed smaller than ?x. * the parameter increase_width specifies the extend to which an object is wider * Example of us: * (assign (?x width) (function apply_smaller (objects ?x ?y) (settings (increase_width 6)))) draw_line Draws a line between two objects Example of use: (action (function draw_line (objects ?x ?y))) 3 Worked Example The following example is for the Blocks domain. To see the final result for this AP, see the link in section 1.2 for the associated domain and problem files. These can be visualised with this animation profile. The following is an example problem visualised with this animation profile: The animation profile is as follows (comments added with a # symbol): (define (animation blocksworld) # the 'on' predicate takes two parameters (objects) ?x and ?y (:predicate on :parameters (?x ?y) :effect( # the effect of the `on` predicate is that ?x's x value is equal to ?y's x value, and that ?x's y value is equal to ?y's ?y value plus its height. # that is, object ?x is on top of object ?y (equal (?x x y) (?y x (sum y height)) ) ) (:predicate on-table :parameters (?x) :effect( # the predicate on-table specifies that the object should be distributed horizontally, with a y value of 0 # and a margin of 5 (equal (?x x y) (function distribute_horizontal (margin 5)(y 0)) ) (:predicate holding :parameters (?x claw) :effect ( (equal (?x x y) (claw x y)) ) ) # Below are the list of shapes (:shape block #block shape is the default shape type. All domain objects have this type by default :type default # all 'shape' objects have the following properties :properties( (showname false) (x false) (y false) # randomcolor assigns a random color to the object (color (function randomcolor)) (width 80) (height 80) # this is a base64 string representing the image of the object (base64image iVBORw0KGg...oAA) ) ) (:shape claw #custom object types do not appear in the domain #they are mainly cosmetic. This object represents the claw (the claw does not move) :type custom :properties( (showname false) (x 230) (y 500) (color black) (width 80) (height 40) (base64image iVBORw0KGg...oAA) ) ) (:shape board :type custom :properties( (showname false) (x 0) (y 0) (color black) (width panel_size) (height 5) (base64image iVBORw0KGg...oAA) ) ) ) Three other Animation Profiles are provided in the source code under Test/Sample Files. Each of these is commented for readability. 4 Extending the Language 4.1 Extension Areas There are two primary methods of extending the AP language: 1. Object properties (section 2.4) * This is for simple ways of extending the appearance of objects, eg adding rotation or the font of 'showname' 2. Adding functions (section 2.5) * This is for more complex ways of describing object behaviours and interactions, eg adding new object layout options 4.2 Extension Steps Modify the extensions.py file in the directory to add any functions or properties. See the document 'VFG Documentation.md' for more information. In limited advanced cases, exta functions may need to be written for Visualiser (Unity) Add the necessary documentation in this .md file.","title":"Animation Profile"},{"location":"ap_guide/#1-introduction","text":"","title":"1 Introduction"},{"location":"ap_guide/#11-purpose","text":"An Animation Profile (AP) is a user-written PDDL file which tells the Visualiser how a Domain is to be visualised. Each Animation Profile corresponds to one Domain. Essentially, the AP provides a set of visual objects (\"shapes\") within the domain, along with a set of mappings from Predicates to animation behaviours.","title":"1.1 Purpose"},{"location":"ap_guide/#12-scope","text":"The AP Language is designed to be flexible enough to allow for the animation of many simple PDDL domains, such as those found at https://bitbucket.org/planning-researchers/classical-domains/src/208a850d2ff2a27068329ad578ad99af9ec7e5c5/classical/?at=master. Currently, APs have been written for four domains from this repository: Blocks, Towers of Hanoi, Logistics, and Grid. Other simple domains can be visualised in the language. For more complicated domains, additional functions or object properties may be added (See section 4).","title":"1.2 Scope"},{"location":"ap_guide/#2-using-the-language","text":"This section contains complete documentation for the syntax and semantics of the AP language. For a quick starting point to writing your own AP, see section 3.","title":"2 Using the Language"},{"location":"ap_guide/#21-key-components","text":"","title":"2.1 Key Components"},{"location":"ap_guide/#211-predicates","text":"The first content of the AP should be the Predicate blocks. Here is an example of a Predicate block. (:predicate holding :parameters (?x claw) :effect ( (equal (?x x y) (claw x y)) ) ) There should be one or zero Predicate blocks for each Predicate in the Domain. If there is no Predicate block for a Predicate in the domain, the Predicate is ignored by the solver. Predicate Blocks contain: * The name of the Predicate, for example holding . * The parameters of the Predicate. Parameters are objects to which the Predicate applies. For example, holding(?x) means that the predicate on-table is true for the object ?x. * The effect of the Predicate. This is a logical statement concerning object properties which holds true when the predicate holds true. For example, (equal (?x x y) (claw x y)) means that the object ?x is at the object claw . * (Optionally) A Priority: * Specifies a priority in which predicates are solved * Example: * :priority 0 * Higher priority predicates are applied first * This is required to ensure a limited number of domains (eg Towers of Hanoi) can be solved. Typically it is required when multiple predicates affect the same variables.","title":"2.1.1 Predicates"},{"location":"ap_guide/#212-shapes","text":"Shapes are visual objects represented on the screen. An example of a Shape block is: (:shape block :type default :properties( (showname false) (x NULL) (y NULL) (color (function randomcolor)) (width 80) (height 80) (base64image iVBORw0KGg...oAA) ) ) Shape blocks contain: * The name of the shape, for example block * The type of the object. Types can either be default , custom , or predefine . * default objects apply to any objects mentioned in the problem file. A 'block' in the problem file is an example of a default object. * custom objects are additional to the problem file, and are created by the user for visual effect. The 'claw' is an example of a custom object - it mainly serves a visual purpose and is not specified in the problem or domain file. The robot in the Grid domain is another example of a custom object - it is not explicitly mentioned in the domain objects, but its behaviour is still fairly dynamic (moving around etc) * predefine These objects are assigned only to domain objects whose name matches any of the names in the :object field. This is used to apply properties to domain objects with specific naming conventions, for example, key1 , key2 , ... in the Grid domain. * Object properties. These properties govern the position and appearance of the object. See section 2.4 for a detailed list of object properties.","title":"2.1.2 Shapes"},{"location":"ap_guide/#22-syntax","text":"","title":"2.2 Syntax"},{"location":"ap_guide/#221-description","text":"The syntax of the language is based on PDDL syntax, which is itself based on Lisp. See Section 2.2.2 for detailed resources on these languages.","title":"2.2.1 Description"},{"location":"ap_guide/#222-resources","text":"PDDL information: https://en.wikipedia.org/wiki/Planning_Domain_Definition_Language PDDL examples, solver: http://planning.domains/ Lisp information: https://en.wikipedia.org/wiki/Lisp_(programming_language) Lisp Tutorial: https://www.tutorialspoint.com/lisp/","title":"2.2.2 Resources"},{"location":"ap_guide/#23-types","text":"A type is a class of variable to which a property can be assigned. The use of the word 'type' is therefore fairly loose. AP supports a number of 'types': * Integer * Boolean - true or false * Function - Allocates a property based on some function, for example, distribute_horizontal * Color - either a colour constant, eg BLACK , (see below), the RANDOMCOLOR function (see section 2.5), or an rgb value, for example #FAA2B5 * Constant - A number of pre-defined constants exist. These should by convention be written in CAPITALS. * Colours: BLACK, RED, BLUE, GREEN, YELLOW * Integer Constants: PANEL_SIZE * NULL - A NULL value means the user is not specifying the property. NULL properties are typically be set by Predicate rules. A list of the types to which each property can be assigned is in section 2.4.","title":"2.3 Types"},{"location":"ap_guide/#24-object-properties","text":"A number of Object Properties can be assigned for each Shape. * showname (Boolean): whether to display the shape's name on screen * x (Integer): x position of the shape on screen * y (Integer): y position of the shape on screen * colour (Colour): Colour of the shape. Can be a constant (eg BLACK ), an RGB value (eg #FAA2B5 ), or the custom value RANDOMCOLOR which picks a random RGB value. * width (Integer): Width of the object on screen * height: Height of the object on screen * base64image: A Base64 string representing the shape's image. Base64 images can be generated at https://www.base64decode.org/ * depth: Depth of the object on screen. Higher depth objects are drawn behind lower depths. * label: Optional attribute specifying a string label to be drawn on the object.","title":"2.4 Object Properties"},{"location":"ap_guide/#25-functions","text":"Functions have two uses: * In Predicate blocks: here they are 'declarative' in nature and when specified, are true for their parameters * In object properties: Here they return a value (eg random_colour). List of functions: Distribution Distribution functions 'distribute' objects in a certain manner. They are used to lay objects out on the screen. All objects for which the same parameters of 'distribute' are called will be included in the distribution. Distribution works such that objects will be placed in a certain area without overlapping. Between animation frames, objects will not move (unless their positions are reset). distributex This function distributes objects along a horizontal plane. Parameter spacebtwn governs the space between objects Example of use: (assign (?x x) (function distributex (objects ?x) (settings (spacebtwn 40)))) distributey This function distributes objects along a vertical plane. Parameter spacebtwn governs the space between objects Example of use: (assign (?city y) (function distributey (objects ?city))) distribute_grid_around_point This function distributes objects within a grid-like structure Parameter spacebtwn governs the space between objects Example of use: (assign (?p x y) (function distribute_grid_around_point (objects ?p))) distribute_within_objects_vertical This function distributes objects vertically within the bounds of another object. For example, cars can be distributed within a city. Parameter spacebtwn governs the space between objects Example of use: (assign (?r x y) (function distribute_within_objects_vertical (objects ?r ?x)(settings (spacebtw 20)))) distribute_within_objects_horizontal This function distributes objects horizontally within the bounds of another object. For example, cars can be distributed within a city. Example of use: (assign (?obj x) (function distribute_within_objects_horizontal (objects ?obj ?loc))) Other Functions * calculate_label * calculate_label (objects ?obj1 ?obj2)) displays a numeric label for obj1, based on the number of obj2 objects with this function applied to them. For example, if there are 3 instances of calculate label for (a b) (a c) (a d) , then object a will have a label of \"3\". Useful for displaying how many objects are inside another object * Example of use: * (assign (?obj2 label) (function calculate_label (objects ?obj1 ?obj2))) * align_middle * align_middle (objects ?x ?y) aligns objects x to the middle of object y * Example of use: * (assign (?x x) (function align_middle (objects ?x ?y))) * apply_smaller * apply_smaller (objects ?x ?y) sets ?y to be displayed smaller than ?x. * the parameter increase_width specifies the extend to which an object is wider * Example of us: * (assign (?x width) (function apply_smaller (objects ?x ?y) (settings (increase_width 6)))) draw_line Draws a line between two objects Example of use: (action (function draw_line (objects ?x ?y)))","title":"2.5 Functions"},{"location":"ap_guide/#3-worked-example","text":"The following example is for the Blocks domain. To see the final result for this AP, see the link in section 1.2 for the associated domain and problem files. These can be visualised with this animation profile. The following is an example problem visualised with this animation profile: The animation profile is as follows (comments added with a # symbol): (define (animation blocksworld) # the 'on' predicate takes two parameters (objects) ?x and ?y (:predicate on :parameters (?x ?y) :effect( # the effect of the `on` predicate is that ?x's x value is equal to ?y's x value, and that ?x's y value is equal to ?y's ?y value plus its height. # that is, object ?x is on top of object ?y (equal (?x x y) (?y x (sum y height)) ) ) (:predicate on-table :parameters (?x) :effect( # the predicate on-table specifies that the object should be distributed horizontally, with a y value of 0 # and a margin of 5 (equal (?x x y) (function distribute_horizontal (margin 5)(y 0)) ) (:predicate holding :parameters (?x claw) :effect ( (equal (?x x y) (claw x y)) ) ) # Below are the list of shapes (:shape block #block shape is the default shape type. All domain objects have this type by default :type default # all 'shape' objects have the following properties :properties( (showname false) (x false) (y false) # randomcolor assigns a random color to the object (color (function randomcolor)) (width 80) (height 80) # this is a base64 string representing the image of the object (base64image iVBORw0KGg...oAA) ) ) (:shape claw #custom object types do not appear in the domain #they are mainly cosmetic. This object represents the claw (the claw does not move) :type custom :properties( (showname false) (x 230) (y 500) (color black) (width 80) (height 40) (base64image iVBORw0KGg...oAA) ) ) (:shape board :type custom :properties( (showname false) (x 0) (y 0) (color black) (width panel_size) (height 5) (base64image iVBORw0KGg...oAA) ) ) ) Three other Animation Profiles are provided in the source code under Test/Sample Files. Each of these is commented for readability.","title":"3 Worked Example"},{"location":"ap_guide/#4-extending-the-language","text":"","title":"4 Extending the Language"},{"location":"ap_guide/#41-extension-areas","text":"There are two primary methods of extending the AP language: 1. Object properties (section 2.4) * This is for simple ways of extending the appearance of objects, eg adding rotation or the font of 'showname' 2. Adding functions (section 2.5) * This is for more complex ways of describing object behaviours and interactions, eg adding new object layout options","title":"4.1 Extension Areas"},{"location":"ap_guide/#42-extension-steps","text":"Modify the extensions.py file in the directory to add any functions or properties. See the document 'VFG Documentation.md' for more information. In limited advanced cases, exta functions may need to be written for Visualiser (Unity) Add the necessary documentation in this .md file.","title":"4.2 Extension Steps"},{"location":"ug1/","text":"Planning Visualisation - User Guide 1. Overview This document contains the User Guide for Planning Visualiser. The Planning Visualiser is an open-source program which visualises solutions to Planning Problems. It is an executable Unity architecture in a browser. 1.1 Planning Problems For information about Planning Problems, see http://planning.domains/ Our application uses one \u2018Animation Profile\u2019 per problem domain. An Animation Profile is a user-written PDDL file which tells the Visualiser how a Domain is to be visualised. See the developer docs for more information. 1.2 Scope Planning Visualiser currently has Animation Profiles for four problem domains; Blocks, Grid, Towers of Hanoi, and Logistics. Other simple problem domains may be added by writing an Animation Profile (see section 3.2). Planning visualiser can generate a solution using the solver on http://planning.domains/ . Alternatively, the user can provide their own solution from any solver, provided it conforms to the correct format. 2. Using the system 2.1 Visualise Built-in Domains 2.1.1 Select Files From the home screen, two options are available: Build visualisation from Problem Choose this option to generate a visualisation for a given problem Requires the following files: Domain PDDL, Problem PDDL, Animation Profile PPDL. Files for existing domains are located in the bitbucket repository under Test/Sample Files. A custom URL can be chosen to connect to any solver. The default is solver.planning.domains Build visualisation from Solution VFG Choose this option to view the visualisation for an existing Visalisation file Reuqires the following file: Visualisation File This allows the user to generate a visualisation file once, and watch it multile times or share it with others Once the correct files are uplodaded, the user will be taken to the Visualiser screen. 2.1.2 Visualise Solution The visualisation page has several parts. Steps Panel: Shows all the steps in the solution. Steps can be clicked to navigate the animation to that step. Step Information Panel: shows detailed information for each step, including actions. Animation Panel: displays the animation. Objects in the domain are darkened when they are part of a satisfied subgoal. Control Panel: buttons to control the animation. These include changing the speed of the animation, Play/Pause, Step Forward/Backwards, Replay Subgoal panel: Shows all subgoals (predicates which comprise the goal state). Subgoals change colour when they are satisfied. Clicking on the subgoal opens a dropdown list to all of the steps in which the subgoal is satisfied. Header Bar: Contains Home button, Help button, and a button to download the Visualisation file. This downloaded visualisation file can be shared with others or re-watched. 2.2 Visualise a new Domain This can be done, for many simple domains, with no modification to the system. To add a new domain: Write or obtain a Domain PDDL file for the problem domain. Many domains can be found at https://bitbucket.org/planning-researchers/classical-domains/src/208a850d2ff2a27068329ad578ad99af9ec7e5c5/classical/?at=master Write an Animation Profile which corresponds to the domain file. For documentation on the Animation Profile Language, see the file \u2018Animation Profile Language\u2019 Follow the steps in 2.1 to view a visualisation with the new Animation Profile. 2.3 Video Record a Visualisation A video recording of the visualisation can be created so that the final animation can be easily shared or re-reviewed independently of the system. The below recommendations are one way of recording the animation, however many other methods and tools exist to achieve this. 2.3.1 MacOS Users To video record the visualisation, have the animation you wish to record on your screen, then complete the following steps: Launch the pre-installed QuickTime Player application Select \u201cFile\u201d and choose \u201cNew Screen Recording\u201d To decide whether mouse clicks and sounds appear in your recording or not, click the small, white arrow and select the appropriate options from the drop-down menu. When ready, click the red record button. You will need to select what you want to record. To record the entire screen, click once anywhere. To record only a portion of it, click and drag a box and then click \u201cStart Recording.\u201d When finished, navigate to the menu bar and click the stop recording button designated by the square symbol. To save your recording, click \u201cFile\u201d and then\"Save\", and choose an appropriate save location and name for the recording. View and share file as you would with any other media file. Instructions adapted from https://www.digitaltrends.com/computing/how-to-record-your-computer-screen/ 2.3.2 Windows Users To video record the visualisation, have the animation you wish to record on your screen, then complete the following steps: Press the Windows key and the letter G at the same time to open the Game Bar dialog (this will pop up on your screen). Check the \u201cYes, this is a game\u201d checkbox to load the Game Bar. This is the procedure regardless of what you are recording. Click on the Start Recording button, or press Win + Alt + R to start screen recording. Stop the recording by clicking on the red recording button on the pop-up. The video can be accessed via your Videos folder, inside the Captures folder. Instructions adapted from https://www.laptopmag.com/articles/how-to-video-screen-capture-windows-10 3. Extending the system Planning Visualiser is modular and can be extended in multiple ways. Many simple domains can be captured in the existing Animation Profile language. For more complex domains, modifications may need to be made to the application. Detailed developer documentation is available at the project's repository (under /Docs) .","title":"User Guide"},{"location":"ug1/#planning-visualisation-user-guide","text":"","title":"Planning Visualisation - User Guide"},{"location":"ug1/#1-overview","text":"This document contains the User Guide for Planning Visualiser. The Planning Visualiser is an open-source program which visualises solutions to Planning Problems. It is an executable Unity architecture in a browser.","title":"1. Overview"},{"location":"ug1/#11-planning-problems","text":"For information about Planning Problems, see http://planning.domains/ Our application uses one \u2018Animation Profile\u2019 per problem domain. An Animation Profile is a user-written PDDL file which tells the Visualiser how a Domain is to be visualised. See the developer docs for more information.","title":"1.1 Planning Problems"},{"location":"ug1/#12-scope","text":"Planning Visualiser currently has Animation Profiles for four problem domains; Blocks, Grid, Towers of Hanoi, and Logistics. Other simple problem domains may be added by writing an Animation Profile (see section 3.2). Planning visualiser can generate a solution using the solver on http://planning.domains/ . Alternatively, the user can provide their own solution from any solver, provided it conforms to the correct format.","title":"1.2 Scope"},{"location":"ug1/#2-using-the-system","text":"","title":"2. Using the system"},{"location":"ug1/#21-visualise-built-in-domains","text":"","title":"2.1 Visualise Built-in Domains"},{"location":"ug1/#211-select-files","text":"From the home screen, two options are available: Build visualisation from Problem Choose this option to generate a visualisation for a given problem Requires the following files: Domain PDDL, Problem PDDL, Animation Profile PPDL. Files for existing domains are located in the bitbucket repository under Test/Sample Files. A custom URL can be chosen to connect to any solver. The default is solver.planning.domains Build visualisation from Solution VFG Choose this option to view the visualisation for an existing Visalisation file Reuqires the following file: Visualisation File This allows the user to generate a visualisation file once, and watch it multile times or share it with others Once the correct files are uplodaded, the user will be taken to the Visualiser screen.","title":"2.1.1 Select Files"},{"location":"ug1/#212-visualise-solution","text":"The visualisation page has several parts. Steps Panel: Shows all the steps in the solution. Steps can be clicked to navigate the animation to that step. Step Information Panel: shows detailed information for each step, including actions. Animation Panel: displays the animation. Objects in the domain are darkened when they are part of a satisfied subgoal. Control Panel: buttons to control the animation. These include changing the speed of the animation, Play/Pause, Step Forward/Backwards, Replay Subgoal panel: Shows all subgoals (predicates which comprise the goal state). Subgoals change colour when they are satisfied. Clicking on the subgoal opens a dropdown list to all of the steps in which the subgoal is satisfied. Header Bar: Contains Home button, Help button, and a button to download the Visualisation file. This downloaded visualisation file can be shared with others or re-watched.","title":"2.1.2 Visualise Solution"},{"location":"ug1/#22-visualise-a-new-domain","text":"This can be done, for many simple domains, with no modification to the system. To add a new domain: Write or obtain a Domain PDDL file for the problem domain. Many domains can be found at https://bitbucket.org/planning-researchers/classical-domains/src/208a850d2ff2a27068329ad578ad99af9ec7e5c5/classical/?at=master Write an Animation Profile which corresponds to the domain file. For documentation on the Animation Profile Language, see the file \u2018Animation Profile Language\u2019 Follow the steps in 2.1 to view a visualisation with the new Animation Profile.","title":"2.2 Visualise a new Domain"},{"location":"ug1/#23-video-record-a-visualisation","text":"A video recording of the visualisation can be created so that the final animation can be easily shared or re-reviewed independently of the system. The below recommendations are one way of recording the animation, however many other methods and tools exist to achieve this.","title":"2.3 Video Record a Visualisation"},{"location":"ug1/#231-macos-users","text":"To video record the visualisation, have the animation you wish to record on your screen, then complete the following steps: Launch the pre-installed QuickTime Player application Select \u201cFile\u201d and choose \u201cNew Screen Recording\u201d To decide whether mouse clicks and sounds appear in your recording or not, click the small, white arrow and select the appropriate options from the drop-down menu. When ready, click the red record button. You will need to select what you want to record. To record the entire screen, click once anywhere. To record only a portion of it, click and drag a box and then click \u201cStart Recording.\u201d When finished, navigate to the menu bar and click the stop recording button designated by the square symbol. To save your recording, click \u201cFile\u201d and then\"Save\", and choose an appropriate save location and name for the recording. View and share file as you would with any other media file. Instructions adapted from https://www.digitaltrends.com/computing/how-to-record-your-computer-screen/","title":"2.3.1 MacOS Users"},{"location":"ug1/#232-windows-users","text":"To video record the visualisation, have the animation you wish to record on your screen, then complete the following steps: Press the Windows key and the letter G at the same time to open the Game Bar dialog (this will pop up on your screen). Check the \u201cYes, this is a game\u201d checkbox to load the Game Bar. This is the procedure regardless of what you are recording. Click on the Start Recording button, or press Win + Alt + R to start screen recording. Stop the recording by clicking on the red recording button on the pop-up. The video can be accessed via your Videos folder, inside the Captures folder. Instructions adapted from https://www.laptopmag.com/articles/how-to-video-screen-capture-windows-10","title":"2.3.2 Windows Users"},{"location":"ug1/#3-extending-the-system","text":"Planning Visualiser is modular and can be extended in multiple ways. Many simple domains can be captured in the existing Animation Profile language. For more complex domains, modifications may need to be made to the application. Detailed developer documentation is available at the project's repository (under /Docs) .","title":"3. Extending the system"}]}